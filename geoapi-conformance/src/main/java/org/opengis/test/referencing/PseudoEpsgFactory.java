/*
 *    GeoAPI - Java interfaces for OGC/ISO standards
 *    Copyright © 2011-2024 Open Geospatial Consortium, Inc.
 *    http://www.geoapi.org
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package org.opengis.test.referencing;

import java.util.Set;
import java.util.Map;
import java.util.HashMap;
import java.util.Objects;
import java.util.Optional;
import javax.measure.Unit;
import javax.measure.quantity.Angle;
import javax.measure.quantity.Length;

import org.opengis.parameter.*;
import org.opengis.referencing.*;
import org.opengis.referencing.cs.*;
import org.opengis.referencing.crs.*;
import org.opengis.referencing.datum.*;
import org.opengis.referencing.operation.*;
import org.opengis.referencing.RegisterOperations;
import org.opengis.metadata.citation.Citation;
import org.opengis.util.Factory;
import org.opengis.util.FactoryException;
import org.opengis.util.UnimplementedServiceException;
import org.opengis.test.util.PseudoFactory;
import org.opengis.test.ValidatorContainer;
import org.opengis.test.Units;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Assumptions.assumeTrue;
import static org.opengis.test.referencing.ObjectFactoryTest.*;


/**
 * Creates referencing objects for a limited set of hard-coded EPSG codes
 * using {@link ObjectFactory} and {@link MathTransformFactory}.
 * This pseudo-factory can be used with implementations that do not support
 * (or don't want to test) a "real" {@link CRSAuthorityFactory} for the EPSG database.
 *
 * @author  Martin Desruisseaux (Geomatys)
 * @author  Johann Sorel (Geomatys)
 * @author  Michael Arneson (INT)
 * @version 3.1
 * @since   3.1
 */
@SuppressWarnings("strictfp")   // Because we still target Java 11.
public strictfp class PseudoEpsgFactory extends PseudoFactory implements RegisterOperations,
        CRSAuthorityFactory, CSAuthorityFactory, DatumAuthorityFactory
{
    /**
     * The reciprocal of the conversion from US feets to metres.
     */
    static final double R_US_FEET = 3.2808333333333333333;

    /**
     * Conversion from Clarke's 1865 feet to metres.
     */
    static final double CLARKE_FEET = 0.3047972654;

    /**
     * Conversion from feet to metres.
     */
    static final double FEET = 0.3048;

    /**
     * Conversion from links to metres
     */
    static final double LINKS = 0.66 * FEET;

    /**
     * Provider of predefined {@link Unit} instances (degree, metre, second, <i>etc</i>).
     */
    protected final Units units;

    /**
     * Provider of factories to use for building geodetic objects.
     * {@code PseudoEpsgFactory} will use only the following factories:
     * {@link ObjectFactory} subtypes, {@link CoordinateOperationAuthorityFactory}
     * (only for fetching {@link OperationMethod}) and {@link MathTransformFactory}.
     *
     * @see RegisterOperations#getFactory(Class)
     */
    protected final RegisterOperations factories;

    /**
     * The set of validators to use for verifying objects conformance (never {@code null}).
     */
    protected final ValidatorContainer validators;

    /**
     * Creates a new pseudo-factory which will use object factories provided by the given {@code factories} argument.
     * The {@link ObjectFactory} instances will be obtained by calls to {@link RegisterOperations#getFactory(Class)}.
     * If the latter method returns an empty value, then the {@code createFoo(…)} methods that depend on the missing
     * factory will throw {@link org.opentest4j.TestAbortedException}.
     *
     * @param  units       provider of predefined {@link Unit} instances.
     * @param  factories   provider of factories for creating geodetic objects.
     * @param  validators  the set of validators to use for verifying objects conformance,
     *                     Cannot be {@code null}. If there is no particular validators,
     *                     use {@link org.opengis.test.Validators#DEFAULT}.
     */
    public PseudoEpsgFactory(Units units, RegisterOperations factories, ValidatorContainer validators) {
        this.units      = Objects.requireNonNull(units, "The units cannot be null. Do you mean Units.getDefault()?");
        this.factories  = Objects.requireNonNull(factories, "The provider of factories cannot be null.");
        this.validators = Objects.requireNonNull(validators, "The validators cannot be null. Do you mean Validators.DEFAULT?");
    }

    /**
     * Returns a component factory implemented by this {@code PseudoEpsgFactory}. If the {@code type} argument is
     * {@link CRSAuthorityFactory}, {@link CSAuthorityFactory} or {@link DatumAuthorityFactory}, then this method
     * returns {@code this}. Otherwise this method returns an empty value (it does not delegate to the wrapped
     * {@link #factories} instance).
     *
     * @param  <T>   compile-time value of the {@code type} argument.
     * @param  type  the desired type of factory.
     * @return factory of the specified type.
     * @throws NullPointerException if the specified type is null.
     * @throws IllegalArgumentException if the specified type is not one of the above-cited values.
     */
    @Override
    public <T extends Factory> Optional<T> getFactory(final Class<? extends T> type) {
        if (type == CRSAuthorityFactory.class || type == CSAuthorityFactory.class || type == DatumAuthorityFactory.class) {
            return Optional.of(type.cast(this));
        } else {
            return Optional.empty();
        }
    }

    /**
     * Returns the factory of the given type if present, or interrupts the test otherwise.
     *
     * @param  <T>      compile-time value of the {@code type} argument.
     * @param  type     the desired type of factory.
     * @param  message  message to report if the desired factory is not present.
     * @return factory of the specified type.
     */
    private <T extends Factory> T getFactoryOrAbort(final Class<T> type, final String message) throws FactoryException {
        final Optional<T> factory = factories.getFactory(type);
        assumeTrue(factory.isPresent(), message);
        return factory.get();
    }

    /**
     * Returns the given EPSG code as an integer.
     *
     * @param  code  the EPSG code to parse.
     * @return the EPSG code as an integer.
     * @throws NoSuchAuthorityCodeException if the given code cannot be parsed as an integer.
     */
    private static int parseCode(String code) throws NoSuchAuthorityCodeException {
        final int s = code.lastIndexOf(':');
        if (s >= 0) {
            final String authority = code.substring(0, s).trim();
            if (!authority.equalsIgnoreCase("EPSG")) {
                throw new NoSuchAuthorityCodeException("Unsupported \"" + authority + "\" authority.", "EPSG", code);
            }
            code = code.substring(s+1).trim();
        }
        try {
            return Integer.parseInt(code);
        } catch (NumberFormatException cause) {
            NoSuchAuthorityCodeException e = new NoSuchAuthorityCodeException(
                    "Unparseable EPSG code: " + code, "EPSG", code);
            e.initCause(cause);
            throw e;
        }
    }

    /**
     * Creates the exception to be thrown when the given code has not been recognized.
     *
     * @param  code   the code as a numerical value.
     * @param  given  the code as given by the user.
     * @return the exception to throw.
     */
    private static NoSuchAuthorityCodeException noSuchAuthorityCode(final int code, final String given) {
        final String codeAsText = String.valueOf(code);
        return new NoSuchAuthorityCodeException("No case implemented for EPSG:" + codeAsText,
                "EPSG", codeAsText, given);
    }

    /**
     * Returns the organization or party responsible for definition and maintenance of the database.
     * The default implementation returns {@code null}.
     *
     * @return the organization responsible for definition of the database.
     */
    @Override
    public Citation getAuthority() {
        return null;
    }

    /**
     * Returns the set of authority codes for objects of the given type.
     * The default implementation returns an empty set.
     *
     * @param  type  the spatial reference objects type.
     * @return the set of authority codes for spatial reference objects of the given type.
     * @throws FactoryException if this method cannot provide the requested information.
     *
     * @todo Needs to be implemented.
     */
    @Override
    public Set<String> getAuthorityCodes(final Class<? extends IdentifiedObject> type) throws FactoryException {
        return Set.of();
    }

    /**
     * Builds a map of properties for a referencing object to be built. The map shall contain
     * at least the {@link IdentifiedObject#NAME_KEY} identifier associated to the given value.
     * Subclasses can override this method in order to provide more information if they wish.
     *
     * @param  code  the EPSG code of the object being built.
     * @param  name  the name of the object being built.
     * @return a map containing the properties for the object to create.
     */
    protected Map<String,Object> createPropertiesMap(final int code, final String name) {
        final Map<String,Object> properties = new HashMap<>(4);
        assertNull(properties.put(IdentifiedObject.NAME_KEY, name));
        assertNull(properties.put(IdentifiedObject.IDENTIFIERS_KEY, new EPSGIdentifier(code)));
        return properties;
    }

    /**
     * Returns an arbitrary object from a code.
     *
     * <table class="ogc">
     *   <caption>Supported codes</caption>
     *   <tr><th>Code</th> <th>Name</th></tr>
     *   <tr><td>4326</td> <td>WGS 84</td></tr>
     *   <tr><td>6326</td> <td>World Geodetic System 1984</td></tr>
     *   <tr><td>6422</td> <td>Ellipsoidal 2D CS. Axes: latitude, longitude. Orientations: north, east. UoM: degree</td></tr>
     * </table>
     *
     * @param  code  value allocated by authority.
     * @return the datum for the given code.
     * @throws FactoryException if the object creation failed.
     *
     * @deprecated This method is ambiguous.
     */
    @Override
    @SuppressWarnings("removal")
    @Deprecated(since = "3.1", forRemoval = true)
    public IdentifiedObject createObject(final String code) throws FactoryException {
        final int id = parseCode(code);
        switch (id) {
            case 6326: return createDatum(code);
            case 6422: return createCoordinateSystem(code);
            case 4326: return createCoordinateReferenceSystem(code);
            default:   throw noSuchAuthorityCode(id, code);
        }
    }

    /**
     * Returns a description of the object corresponding to a code.
     *
     * @param  code  value allocated by authority.
     * @return a description of the object, or {@code null} if the object
     *         corresponding to the specified {@code code} has no description.
     * @throws NoSuchAuthorityCodeException if the specified {@code code} was not found.
     * @throws FactoryException if the query failed for some other reason.
     *
     * @deprecated This method is ambiguous because the EPSG geodetic registry may allocate
     *             the same code to different kinds of object.
     */
    @Override
    @SuppressWarnings("removal")
    @Deprecated(since="3.1", forRemoval=true)
    public org.opengis.util.InternationalString getDescriptionText(String code) throws FactoryException {
        return getDescriptionText(CoordinateReferenceSystem.class, code).orElse(null);
    }




    //  ╔═════════════════════════════════════════════════════════════╗
    //  ║                                                             ║
    //  ║                  D A T U M   F A C T O R Y                  ║
    //  ║                                                             ║
    //  ╚═════════════════════════════════════════════════════════════╝

    /**
     * Creates an arbitrary datum from a code. The current implementation supports
     * only a subset of the codes supported by more specialized methods.
     *
     * <table class="ogc">
     *   <caption>Supported codes</caption>
     *   <tr><th>Code</th> <th>Name</th></tr>
     *   <tr><td>6326</td> <td>World Geodetic System 1984</td></tr>
     * </table>
     *
     * @param  code  value allocated by authority.
     * @return the datum for the given code.
     * @throws FactoryException if the object creation failed.
     */
    @Override
    public Datum createDatum(final String code) throws FactoryException {
        final int id = parseCode(code);
        switch (id) {
            case 6326: return createGeodeticDatum(code);
            default:   throw noSuchAuthorityCode(id, code);
        }
    }

    /**
     * Creates a geodetic reference frame from a code.
     *
     * <table class="ogc">
     *   <caption>Supported codes</caption>
     *   <tr><th>Code</th> <th>Name</th></tr>
     *   <tr><td>6326</td> <td>World Geodetic System 1984</td></tr>
     *   <tr><td>6284</td> <td>Pulkovo 1942</td></tr>
     * </table>
     *
     * @param  code  value allocated by authority.
     * @return the datum for the given code.
     * @throws FactoryException if the object creation failed.
     */
    @Override
    public GeodeticDatum createGeodeticDatum(final String code) throws FactoryException {
        final String name;
        final int ellipsoid;
        final int primeMeridian;
        final int id = parseCode(code);
        switch (id) {
            case 6326: name="World Geodetic System 1984"; ellipsoid=7030; primeMeridian=8901; break;
            case 6284: name="Pulkovo 1942";               ellipsoid=7024; primeMeridian=8901; break;
            default:   throw noSuchAuthorityCode(id, code);
        }
        final var datumFactory = getFactoryOrAbort(DatumFactory.class, NO_DATUM_FACTORY);
        final GeodeticDatum object = datumFactory.createGeodeticDatum(createPropertiesMap(id, name),
                createEllipsoid    (String.valueOf(ellipsoid)),
                createPrimeMeridian(String.valueOf(primeMeridian)));
        validators.validate(object);
        return object;
    }

    /**
     * Creates an ellipsoid from a code.
     *
     * <table class="ogc">
     *   <caption>Supported codes</caption>
     *   <tr><th>Code</th> <th>Name</th></tr>
     *   <tr><td>7001</td> <td>Airy 1830</td></tr>
     *   <tr><td>7004</td> <td>Bessel 1841</td></tr>
     *   <tr><td>7011</td> <td>Clarke 1880 (IGN)</td></tr>
     *   <tr><td>7019</td> <td>GRS 1980</td></tr>
     *   <tr><td>7022</td> <td>International 1924</td></tr>
     *   <tr><td>7024</td> <td>Krassowsky 1940</td></tr>
     *   <tr><td>7030</td> <td>WGS 84</td></tr>
     * </table>
     *
     * @param  code  value allocated by authority.
     * @return the ellipsoid for the given code.
     * @throws FactoryException if the object creation failed.
     */
    @Override
    public Ellipsoid createEllipsoid(final String code) throws FactoryException {
        final String name;
        final double semiMajorAxis;
        double semiMinorAxis = Double.NaN;
        double inverseFlattening = Double.NaN;
        int    unitCode = 9001;                     // Default unit is metre.
        final int id = parseCode(code);
        switch (id) {
            case 7030: name="WGS 84";             semiMajorAxis=6378137;     inverseFlattening=298.257223563; break;
            case 7019: name="GRS 1980";           semiMajorAxis=6378137;     inverseFlattening=298.2572221;   break;
            case 7001: name="Airy 1830";          semiMajorAxis=6377563.396; inverseFlattening=299.3249646;   break;
            case 7004: name="Bessel 1841";        semiMajorAxis=6377397.155; inverseFlattening=299.1528128;   break;
            case 7024: name="Krassowsky 1940";    semiMajorAxis=6378245;     inverseFlattening=298.3;         break;
            case 7022: name="International 1924"; semiMajorAxis=6378388;     inverseFlattening=297;           break;
            case 7011: name="Clarke 1880 (IGN)";  semiMajorAxis=6378249.2;   semiMinorAxis=6356515;           break;
            default:   throw noSuchAuthorityCode(id, code);
        }
        final var datumFactory = getFactoryOrAbort(DatumFactory.class, NO_DATUM_FACTORY);
        final Map<String,?> properties = createPropertiesMap(id, name);
        final Unit<Length> unit = createUnit(String.valueOf(unitCode)).asType(Length.class);
        final Ellipsoid object;
        if (Double.isNaN(inverseFlattening)) {
            object = datumFactory.createEllipsoid(properties, semiMajorAxis, semiMinorAxis, unit);
        } else {
            object = datumFactory.createFlattenedSphere(properties, semiMajorAxis, inverseFlattening, unit);
        }
        validators.validate(object);
        return object;
    }

    /**
     * Creates a prime meridian from a code.
     *
     * <table class="ogc">
     *   <caption>Supported codes</caption>
     *   <tr><th>Code</th> <th>Name</th></tr>
     *   <tr><td>8901</td> <td>Greenwich</td></tr>
     *   <tr><td>8903</td> <td>Paris</td></tr>
     *   <tr><td>8908</td> <td>Jakarta</td></tr>
     * </table>
     *
     * @param  code  value allocated by authority.
     * @return the prime meridian for the given code.
     * @throws FactoryException if the object creation failed.
     */
    @Override
    public PrimeMeridian createPrimeMeridian(final String code) throws FactoryException {
        final String name;
        final double longitude;
        final int    unit;
        final int id = parseCode(code);
        switch (id) {
            case 8901: name="Greenwich"; longitude=  0.0;              unit=9102; break;
            case 8903: name="Paris";     longitude=  2.5969213;        unit=9105; break;
            case 8908: name="Jakarta";   longitude=106.80771944444444; unit=9102; break;
            default:   throw noSuchAuthorityCode(id, code);
        }
        final var datumFactory = getFactoryOrAbort(DatumFactory.class, NO_DATUM_FACTORY);
        final PrimeMeridian object = datumFactory.createPrimeMeridian(createPropertiesMap(id, name),
                longitude, createUnit(String.valueOf(unit)).asType(Angle.class));
        validators.validate(object);
        return object;
    }




    //  ╔═════════════════════════════════════════════════════════════╗
    //  ║                                                             ║
    //  ║      C O O R D I N A T E   S Y S T E M   F A C T O R Y      ║
    //  ║                                                             ║
    //  ╚═════════════════════════════════════════════════════════════╝

    /**
     * Creates an arbitrary coordinate system from a code. The current implementation
     * supports only a subset of the codes supported by more specialized methods.
     *
     * <table class="ogc">
     *   <caption>Supported codes</caption>
     *   <tr><th>Code</th> <th>Name</th></tr>
     *   <tr><td>6422</td> <td>Ellipsoidal 2D CS. Axes: latitude, longitude. Orientations: north, east. UoM: degree</td></tr>
     * </table>
     *
     * @param  code  value allocated by authority.
     * @return the coordinate system for the given code.
     * @throws FactoryException if the object creation failed.
     */
    @Override
    public CoordinateSystem createCoordinateSystem(final String code) throws FactoryException {
        final int id = parseCode(code);
        switch (id) {
            case 6422: return createEllipsoidalCS(code);
            default:   throw noSuchAuthorityCode(id, code);
        }
    }

    /**
     * Creates a Cartesian coordinate system from a code.
     *
     * <table class="ogc">
     *   <caption>Supported codes</caption>
     *   <tr><th>Code</th> <th>Name</th></tr>
     *   <tr><td>4400</td> <td>Cartesian 2D CS. Axes: easting, northing (E,N). Orientations: east, north. UoM: m.</td></tr>
     *   <tr><td>4495</td> <td>Cartesian 2D CS. Axes: easting, northing (X,Y). Orientations: east, north. UoM: ft.</td></tr>
     *   <tr><td>4497</td> <td>Cartesian 2D CS. Axes: easting, northing (X,Y). Orientations: east, north. UoM: ftUS.</td></tr>
     *   <tr><td>4498</td> <td>Cartesian 2D CS. Axes: easting, northing (Y,X). Orientations: east, north. UoM: m.</td></tr>
     *   <tr><td>4499</td> <td>Cartesian 2D CS. Axes: easting, northing (X,Y). Orientations: east, north. UoM: m.</td></tr>
     *   <tr><td>4500</td> <td>Cartesian 2D CS. Axes: northing, easting (N,E). Orientations: north, east. UoM: m.</td></tr>
     *   <tr><td>4530</td> <td>Cartesian 2D CS. Axes: northing, easting (X,Y). Orientations: north, east. UoM: m.</td></tr>
     *   <tr><td>4532</td> <td>Cartesian 2D CS. Axes: northing, easting (Y,X). Orientations: north, east. UoM: m.</td></tr>
     *   <tr><td>4534</td> <td>Cartesian 2D CS. Axes: northing, easting (no abbrev). Orientations: north, east. UoM: m.</td></tr>
     *   <tr><td>6503</td> <td>Cartesian 2D CS. Axes: westing, southing (Y,X). Orientations: west, south. UoM: m.</td></tr>
     *   <tr><td>6500</td> <td>Earth centred, earth fixed, righthanded 3D coordinate system,
     *     consisting of 3 orthogonal axes with X and Y axes in the equatorial plane,
     *     positive Z-axis parallel to mean earth rotation axis and pointing towards North Pole.
     *     UoM: m</td></tr>
     * </table>
     *
     * @param  code  value allocated by authority.
     * @return the coordinate system for the given code.
     * @throws FactoryException if the object creation failed.
     */
    @Override
    public CartesianCS createCartesianCS(final String code) throws FactoryException {
        final String name;
        final int[] axes;
        final int id = parseCode(code);
        switch (id) {
            case 4400: name = "Cartesian 2D CS. Axes: easting, northing (E,N). Orientations: east, north. UoM: m.";       axes = new int[] {  1,   2}; break;
            case 4495: name = "Cartesian 2D CS. Axes: easting, northing (X,Y). Orientations: east, north. UoM: ft.";      axes = new int[] { 33,  34}; break;
            case 4497: name = "Cartesian 2D CS. Axes: easting, northing (X,Y). Orientations: east, north. UoM: ftUS.";    axes = new int[] { 37,  38}; break;
            case 4498: name = "Cartesian 2D CS. Axes: easting, northing (Y,X). Orientations: east, north. UoM: m.";       axes = new int[] { 39,  40}; break;
            case 4499: name = "Cartesian 2D CS. Axes: easting, northing (X,Y). Orientations: east, north. UoM: m.";       axes = new int[] { 41,  42}; break;
            case 4500: name = "Cartesian 2D CS. Axes: northing, easting (N,E). Orientations: north, east. UoM: m.";       axes = new int[] { 44,  43}; break;
            case 4530: name = "Cartesian 2D CS. Axes: northing, easting (X,Y). Orientations: north, east. UoM: m.";       axes = new int[] { 48,  47}; break;
            case 4532: name = "Cartesian 2D CS. Axes: northing, easting (Y,X). Orientations: north, east. UoM: m.";       axes = new int[] { 52,  51}; break;
            case 4534: name = "Cartesian 2D CS. Axes: northing, easting (no abbrev). Orientations: north, east. UoM: m."; axes = new int[] {183, 184}; break;
            case 6503: name = "Cartesian 2D CS. Axes: westing, southing (Y,X). Orientations: west, south. UoM: m.";       axes = new int[] {122, 123}; break;
            case 6500: {
                name = "Earth centred, earth fixed, righthanded 3D coordinate system, "
                     + "consisting of 3 orthogonal axes with X and Y axes in the equatorial plane, "
                     + "positive Z-axis parallel to mean earth rotation axis and pointing towards North Pole. "
                     + "UoM: m";
                axes = new int[] {115, 116, 117};
                break;
            }
            default: throw noSuchAuthorityCode(id, code);
        }
        final var csFactory = getFactoryOrAbort(CSFactory.class, NO_CS_FACTORY);
        final Map<String,?> properties = createPropertiesMap(id, name);
        final CartesianCS object;
        if (axes.length >= 3) {
            object = csFactory.createCartesianCS(properties,
                    createCoordinateSystemAxis(String.valueOf(axes[0])),
                    createCoordinateSystemAxis(String.valueOf(axes[1])),
                    createCoordinateSystemAxis(String.valueOf(axes[2])));
        } else {
            object = csFactory.createCartesianCS(properties,
                    createCoordinateSystemAxis(String.valueOf(axes[0])),
                    createCoordinateSystemAxis(String.valueOf(axes[1])));
        }
        validators.validate(object);
        return object;
    }

    /**
     * Creates an ellipsoidal coordinate system from a code.
     *
     * <table class="ogc">
     *   <caption>Supported codes</caption>
     *   <tr><th>Code</th> <th>Name</th></tr>
     *   <tr><td>6403</td> <td>Ellipsoidal 2D CS. Axes: latitude, longitude. Orientations: north, east. UoM: grads.</td></tr>
     *   <tr><td>6422</td> <td>Ellipsoidal 2D CS. Axes: latitude, longitude. Orientations: north, east. UoM: degree</td></tr>
     *   <tr><td>6423</td> <td>Ellipsoidal 3D CS. Axes: latitude, longitude, ellipsoidal height. Orientations: north, east, up. UoM: degree, degree, metre.</td></tr>
     *   <tr><td>6424</td> <td>Ellipsoidal 2D CS. Axes: longitude, latitude. Orientations: east, north. UoM: degree</td></tr>
     * </table>
     *
     * @param  code  value allocated by authority.
     * @return the coordinate system for the given code.
     * @throws FactoryException if the object creation failed.
     */
    @Override
    public EllipsoidalCS createEllipsoidalCS(final String code) throws FactoryException {
        final String name;
        final int[] axes;
        final int id = parseCode(code);
        switch (id) {
            case 6403: {
                name = "Ellipsoidal 2D CS. Axes: latitude, longitude. "
                     + "Orientations: north, east. "
                     + "UoM: grads. ";
                axes = new int[] {58, 59};              // Geodetic latitude, Geodetic longitude
                break;
            }
            case 6422: {
                name = "Ellipsoidal 2D CS. Axes: latitude, longitude. "
                     + "Orientations: north, east. "
                     + "UoM: degree";
                axes = new int[] {106, 107};            // Geodetic latitude, Geodetic longitude
                break;
            }
            case 6423: {
                name = "Ellipsoidal 3D CS. Axes: latitude, longitude, ellipsoidal height. "
                     + "Orientations: north, east, up. "
                     + "UoM: degree, degree, metre.";
                axes = new int[] {108, 109, 110};       // Geodetic latitude, Geodetic longitude, Ellipsoidal height
                break;
            }
            case 6424: {
                name = "Ellipsoidal 2D CS. Axes: longitude, latitude. "
                     + "Orientations: east, north. "
                     + "UoM: degree";
                axes = new int[] {220, 221};            // Geodetic longitude, Geodetic latitude
                break;
            }
            default: throw noSuchAuthorityCode(id, code);
        }
        final var csFactory = getFactoryOrAbort(CSFactory.class, NO_CS_FACTORY);
        final Map<String,?> properties = createPropertiesMap(id, name);
        final EllipsoidalCS object;
        if (axes.length >= 3) {
            object = csFactory.createEllipsoidalCS(properties,
                    createCoordinateSystemAxis(String.valueOf(axes[0])),
                    createCoordinateSystemAxis(String.valueOf(axes[1])),
                    createCoordinateSystemAxis(String.valueOf(axes[2])));
        } else {
            object = csFactory.createEllipsoidalCS(properties,
                    createCoordinateSystemAxis(String.valueOf(axes[0])),
                    createCoordinateSystemAxis(String.valueOf(axes[1])));
        }
        validators.validate(object);
        return object;
    }

    /**
     * Creates a vertical coordinate system from a code.
     *
     * <table class="ogc">
     *   <caption>Supported codes</caption>
     *   <tr><th>Code</th> <th>Name</th></tr>
     *   <tr><td>1030</td> <td>Vertical CS. Axis: height (H). Orientation: up. UoM: ft.</td></tr>
     *   <tr><td>6495</td> <td>Vertical CS. Axis: depth (D). Orientation: down. UoM: ft.</td></tr>
     *   <tr><td>6497</td> <td>Vertical CS. Axis: height (H). Orientation: up. UoM: ftUS.</td></tr>
     *   <tr><td>6498</td> <td>Vertical CS. Axis: depth (D). Orientation: down. UoM: m.;</td></tr>
     *   <tr><td>6499</td> <td>Vertical CS. Axis: height (H). Orientation: up. UoM: m.</td></tr>
     * </table>
     *
     * @param  code  value allocated by authority.
     * @return the coordinate system for the given code.
     * @throws FactoryException if this method cannot provide the requested information.
     */
    @Override
    public VerticalCS createVerticalCS(final String code) throws FactoryException {
        final int id = parseCode(code);
        final String name;
        final int axis;
        switch (id) {
            case 1030: name = "Vertical CS. Axis: height (H). Orientation: up. UoM: ft.";   axis = 1082; break;
            case 6495: name = "Vertical CS. Axis: depth (D). Orientation: down. UoM: ft.";  axis =  214; break;
            case 6497: name = "Vertical CS. Axis: height (H). Orientation: up. UoM: ftUS."; axis =  112; break;
            case 6498: name = "Vertical CS. Axis: depth (D). Orientation: down. UoM: m.";   axis =  113; break;
            case 6499: name = "Vertical CS. Axis: height (H). Orientation: up. UoM: m.";    axis =  114; break;
            default: throw noSuchAuthorityCode(id, code);
        }
        final var csFactory = getFactoryOrAbort(CSFactory.class, NO_CS_FACTORY);
        final Map<String,?> properties = createPropertiesMap(id, name);
        final VerticalCS object = csFactory.createVerticalCS(properties,
                createCoordinateSystemAxis(String.valueOf(axis)));
        validators.validate(object);
        return object;
    }

    /**
     * Creates a coordinate system axis from a code.
     *
     * <table class="ogc">
     *   <caption>Supported codes</caption>
     *   <tr><th>Code</th>          <th>Name</th>        <th>Abbreviation</th>    <th>Unit</th></tr>
     *   <tr><td>1, 43</td>         <td>Easting</td>                <td>E</td>    <td>metre</td></tr>
     *   <tr><td>2, 44</td>         <td>Northing</td>               <td>N</td>    <td>metre</td></tr>
     *   <tr><td>41, 51</td>        <td>Easting</td>                <td>X</td>    <td>metre</td></tr>
     *   <tr><td>42, 52</td>        <td>Northing</td>               <td>Y</td>    <td>metre</td></tr>
     *   <tr><td>39, 47</td>        <td>Easting</td>                <td>Y</td>    <td>metre</td></tr>
     *   <tr><td>40, 48</td>        <td>Northing</td>               <td>X</td>    <td>metre</td></tr>
     *   <tr><td>33</td>            <td>Easting</td>                <td>X</td>    <td>foot</td></tr>
     *   <tr><td>34</td>            <td>Northing</td>               <td>Y</td>    <td>foot</td></tr>
     *   <tr><td>37</td>            <td>Easting</td>                <td>X</td>    <td>foot US</td></tr>
     *   <tr><td>38</td>            <td>Northing</td>               <td>Y</td>    <td>foot US</td></tr>
     *   <tr><td>122</td>           <td>Westing</td>                <td>Y</td>    <td>metre</td></tr>
     *   <tr><td>123</td>           <td>Southing</td>               <td>X</td>    <td>metre</td></tr>
     *   <tr><td>183</td>           <td>Northing</td>               <td>none</td> <td>metre</td></tr>
     *   <tr><td>184</td>           <td>Easting</td>                <td>none</td> <td>metre</td></tr>
     *   <tr><td>58</td>            <td>Geodetic latitude</td>      <td>Lat</td>  <td>grad</td></tr>
     *   <tr><td>59</td>            <td>Geodetic longitude</td>     <td>Long</td> <td>grad</td></tr>
     *   <tr><td>106, 108, 221</td> <td>Geodetic latitude</td>      <td>Lat</td>  <td>degree</td></tr>
     *   <tr><td>107, 109, 220</td> <td>Geodetic longitude</td>     <td>Long</td> <td>degree</td></tr>
     *   <tr><td>110</td>           <td>Ellipsoidal height</td>     <td>h</td>    <td>metre</td></tr>
     *   <tr><td>115</td>           <td>Geocentric X</td>           <td>X</td>    <td>metre</td></tr>
     *   <tr><td>116</td>           <td>Geocentric Y</td>           <td>Y</td>    <td>metre</td></tr>
     *   <tr><td>117</td>           <td>Geocentric Z</td>           <td>Z</td>    <td>metre</td></tr>
     *   <tr><td>112</td>           <td>Gravity-related height</td> <td>H</td>    <td>foot US</td></tr>
     *   <tr><td>113</td>           <td>Gravity-related depth</td>  <td>D</td>    <td>metre</td></tr>
     *   <tr><td>114</td>           <td>Gravity-related height</td> <td>H</td>    <td>metre</td></tr>
     *   <tr><td>214</td>           <td>Gravity-related depth</td>  <td>D</td>    <td>foot</td></tr>
     *   <tr><td>1082</td>          <td>Gravity-related height</td> <td>H</td>    <td>foot</td></tr>
     * </table>
     *
     * @param  code  value allocated by authority.
     * @return the axis for the given code.
     * @throws FactoryException if the object creation failed.
     */
    @Override
    public CoordinateSystemAxis createCoordinateSystemAxis(final String code) throws FactoryException {
        final String name;
        final String abbreviation;
        final AxisDirection direction;
        final int unit;
        final int id = parseCode(code);
        switch (id) {
            case    1: case 43: name="Easting";  abbreviation="E";    direction=AxisDirection.EAST;  unit=9001; break;
            case    2: case 44: name="Northing"; abbreviation="N";    direction=AxisDirection.NORTH; unit=9001; break;
            case   41: case 51: name="Easting";  abbreviation="X";    direction=AxisDirection.EAST;  unit=9001; break;
            case   42: case 52: name="Northing"; abbreviation="Y";    direction=AxisDirection.NORTH; unit=9001; break;
            case   39: case 47: name="Easting";  abbreviation="Y";    direction=AxisDirection.EAST;  unit=9001; break;
            case   40: case 48: name="Northing"; abbreviation="X";    direction=AxisDirection.NORTH; unit=9001; break;
            case   33:          name="Easting";  abbreviation="X";    direction=AxisDirection.EAST;  unit=9002; break;
            case   34:          name="Northing"; abbreviation="Y";    direction=AxisDirection.NORTH; unit=9002; break;
            case   37:          name="Easting";  abbreviation="X";    direction=AxisDirection.EAST;  unit=9003; break;
            case   38:          name="Northing"; abbreviation="Y";    direction=AxisDirection.NORTH; unit=9003; break;
            case  122:          name="Westing";  abbreviation="Y";    direction=AxisDirection.WEST;  unit=9001; break;
            case  123:          name="Southing"; abbreviation="X";    direction=AxisDirection.SOUTH; unit=9001; break;
            case  183:          name="Northing"; abbreviation="none"; direction=AxisDirection.NORTH; unit=9001; break;
            case  184:          name="Easting";  abbreviation="none"; direction=AxisDirection.EAST;  unit=9001; break;
            case  108: case 221:
            case  106: name="Geodetic latitude";  abbreviation="Lat";  direction=AxisDirection.NORTH;        unit=9122; break;
            case   58: name="Geodetic latitude";  abbreviation="Lat";  direction=AxisDirection.NORTH;        unit=9105; break;
            case  109: case 220:
            case  107: name="Geodetic longitude";     abbreviation="Long"; direction=AxisDirection.EAST;         unit=9122; break;
            case   59: name="Geodetic longitude";     abbreviation="Long"; direction=AxisDirection.EAST;         unit=9105; break;
            case  110: name="Ellipsoidal height";     abbreviation="h";    direction=AxisDirection.UP;           unit=9001; break;
            case  115: name="Geocentric X";           abbreviation="X";    direction=AxisDirection.GEOCENTRIC_X; unit=9001; break;
            case  116: name="Geocentric Y";           abbreviation="Y";    direction=AxisDirection.GEOCENTRIC_Y; unit=9001; break;
            case  117: name="Geocentric Z";           abbreviation="Z";    direction=AxisDirection.GEOCENTRIC_Z; unit=9001; break;
            case  112: name="Gravity-related height"; abbreviation="H";    direction=AxisDirection.UP;           unit=9003; break;
            case  113: name="Gravity-related depth";  abbreviation="D";    direction=AxisDirection.DOWN;         unit=9001; break;
            case  114: name="Gravity-related height"; abbreviation="H";    direction=AxisDirection.UP;           unit=9001; break;
            case  214: name="Gravity-related depth";  abbreviation="D";    direction=AxisDirection.DOWN;         unit=9002; break;
            case 1082: name="Gravity-related height"; abbreviation="H";    direction=AxisDirection.UP;           unit=9002; break;
            default:  throw noSuchAuthorityCode(id, code);
        }
        final var csFactory = getFactoryOrAbort(CSFactory.class, NO_CS_FACTORY);
        final CoordinateSystemAxis object = csFactory.createCoordinateSystemAxis(createPropertiesMap(id, name),
                abbreviation, direction, createUnit(String.valueOf(unit)));
        validators.validate(object);
        return object;
    }

    /**
     * Returns a predefined unit of measurement from a code.
     *
     * <table class="ogc">
     *   <caption>Supported codes</caption>
     *   <tr><th>Code</th> <th>Name</th></tr>
     *   <tr><td>9001</td> <td>metre</td></tr>
     *   <tr><td>9002</td> <td>foot</td></tr>
     *   <tr><td>9003</td> <td>foot US survey</td></tr>
     *   <tr><td>9102</td> <td>degree</td></tr>
     *   <tr><td>9105</td> <td>grad</td></tr>
     *   <tr><td>9122</td> <td>degree (supplier to define representation)</td></tr>
     * </table>
     *
     * @param  code  value allocated by authority.
     * @return the unit for the given code.
     * @throws FactoryException if the object creation failed.
     */
    @Override
    public Unit<?> createUnit(final String code) throws FactoryException {
        final int id = parseCode(code);
        switch (id) {
            case 9001: return units.metre();
            case 9002: return units.foot();
            case 9003: return units.footSurveyUS();
            case 9122: // Fall through
            case 9102: return units.degree();
            case 9105: return units.grad();
            default:   throw noSuchAuthorityCode(id, code);
        }
    }




    //  ╔═════════════════════════════════════════════════════════════════════════════╗
    //  ║                                                                             ║
    //  ║    C O O R D I N A T E   R E F E R E N C E   S Y S T E M   F A C T O R Y    ║
    //  ║                                                                             ║
    //  ╚═════════════════════════════════════════════════════════════════════════════╝

    /**
     * Creates an arbitrary coordinate reference system from a code. The current implementation
     * supports only a subset of the codes supported by more specialized methods.
     *
     * <table class="ogc">
     *   <caption>Supported codes</caption>
     *   <tr><th>Code</th> <th>Name</th></tr>
     *   <tr><td>4326</td> <td>WGS 84</td></tr>
     * </table>
     *
     * @param  code  value allocated by authority.
     * @return the coordinate reference system for the given code.
     * @throws FactoryException if the object creation failed.
     */
    @Override
    public CoordinateReferenceSystem createCoordinateReferenceSystem(final String code) throws FactoryException {
        final int id = parseCode(code);
        switch (id) {
            case 4326: return createGeographicCRS(code);
            default:   throw noSuchAuthorityCode(id, code);
        }
    }

    /**
     * Creates a geographic coordinate reference system from a code.
     *
     * <table class="ogc">
     *   <caption>Supported codes</caption>
     *   <tr><th>Code</th> <th>Name</th></tr>
     *   <tr><td>4326</td> <td>WGS 84</td></tr>
     *   <tr><td>4284</td> <td>Pulkovo 1942</td></tr>
     * </table>
     *
     * @param  code  value allocated by authority.
     * @return the coordinate reference system for the given code.
     * @throws FactoryException if the object creation failed.
     */
    @Override
    public GeographicCRS createGeographicCRS(final String code) throws FactoryException {
        final String name;
        final int datum;
        final int coordinateSystem;
        final int id = parseCode(code);
        switch (id) {
            case 4326: name="WGS 84";       datum=6326; coordinateSystem=6422; break;
            case 4284: name="Pulkovo 1942"; datum=6284; coordinateSystem=6422; break;
            default:   throw noSuchAuthorityCode(id, code);
        }
        final var crsFactory = getFactoryOrAbort(CRSFactory.class, NO_CRS_FACTORY);
        final GeographicCRS object = crsFactory.createGeographicCRS(createPropertiesMap(id, name),
                createGeodeticDatum(String.valueOf(datum)),
                createEllipsoidalCS(String.valueOf(coordinateSystem)));
        validators.validate(object);
        return object;
    }

    /**
     * Creates a geodetic coordinate reference system from a code.
     * The default implementation delegates to {@link #createGeographicCRS(String)}.
     *
     * @throws FactoryException if this method cannot provide the requested information.
     */
    @Override
    public GeodeticCRS createGeodeticCRS(final String code) throws FactoryException {
        return createGeographicCRS(code);
    }



    //  ╔═════════════════════════════════════════════════════════════════════════════╗
    //  ║                                                                             ║
    //  ║           C O O R D I N A T E   O P E R A T I O N   F A C T O R Y           ║
    //  ║                                                                             ║
    //  ╚═════════════════════════════════════════════════════════════════════════════╝

    /**
     * Returns the parameters to use for creating the {@linkplain CoordinateOperation coordinate
     * operation} identified by the given EPSG code. The coordinate operation is typically a map
     * projection used by exactly one {@linkplain ProjectedCRS projected CRS}, which is listed in
     * the second column for information purpose.
     *
     * <p>The supported codes are determined from the set of examples published in the EPSG guidance
     * document, augmented with other sources (IGNF).
     * The following table lists the supported codes.
     * <i>Codes in italics are not official EPSG codes.</i></p>
     *
     * <table class="ogc">
     *   <caption>Supported codes</caption>
     *   <tr><th>Code</th>  <th>Used by CRS</th><th>CRS or transformation name</th>                 <th>Operation method</th></tr>
     *   <tr><td>19905</td> <td>3002</td>  <td>Makassar / NEIEZ</td>                                <td>Mercator (variant A)</td></tr>
     *   <tr><td>19884</td> <td>3388</td>  <td>Pulkovo 1942 / Caspian Sea Mercator</td>             <td>Mercator (variant B)</td></tr>
     *   <tr><td>3856</td>  <td>3857</td>  <td>WGS 84 / Pseudo-Mercator</td>                        <td>Popular Visualisation Pseudo Mercator</td></tr>
     *   <tr><td>4085</td>  <td>4087</td>  <td>WGS 84 / World Equidistant Cylindrical</td>          <td>Equidistant Cylindrical</td></tr>
     *   <tr><td><i>310642901</i></td> <td><i>310642901</i></td> <td>IGNF:MILLER</td>               <td><i>Miller_Cylindrical</i></td></tr>
     *   <tr><td>19958</td> <td>29873</td> <td>Timbalai 1948 / RSO Borneo (m)</td>                  <td>Hotine Oblique Mercator (variant B)</td></tr>
     *   <tr><td>19916</td> <td>27700</td> <td>OSGB 1936 / British National Grid</td>               <td>Transverse Mercator</td></tr>
     *   <tr><td>17529</td> <td>2053</td>  <td>South African Survey Grid zone 29</td>               <td>Transverse Mercator</td></tr>
     *   <tr><td>19975</td> <td>2314</td>  <td>Trinidad 1903 / Trinidad Grid</td>                   <td>Cassini-Soldner</td></tr>
     *   <tr><td>19878</td> <td>3139</td>  <td>Vanua Levu 1915 / Vanua Levu Grid</td>               <td>Hyperbolic Cassini-Soldner</td></tr>
     *   <tr><td>19910</td> <td>24200</td> <td>JAD69 / Jamaica National Grid</td>                   <td>Lambert Conic Conformal (1SP)</td></tr>
     *   <tr><td>14204</td> <td>32040</td> <td>NAD27 / Texas South Central</td>                     <td>Lambert Conic Conformal (2SP)</td></tr>
     *   <tr> <td>6198</td> <td>6201</td>  <td>Michigan CS27 Central zone</td>                      <td>Lambert Conic Conformal (2SP Michigan)</td></tr>
     *   <tr><td>19902</td> <td>31300</td> <td>Belge 1972 / Belge Lambert 72</td>                   <td>Lambert Conic Conformal (2SP Belgium)</td></tr>
     *   <tr><td>19986</td> <td>3035</td>  <td>ETRS89 / LAEA Europe</td>                            <td>Lambert Azimuthal Equal Area</td></tr>
     *   <tr><td>16061</td> <td>5041</td>  <td>WGS 84 / UPS North (E,N)</td>                        <td>Polar Stereographic (variant A)</td></tr>
     *   <tr><td>19993</td> <td>3032</td>  <td>WGS 84 / Australian Antarctic Polar</td>             <td>Polar Stereographic (variant B)</td></tr>
     *   <tr><td>19983</td> <td>2985</td>  <td>Petrels 1972 / Terre Adelie Polar Stereographic</td> <td>Polar Stereographic (variant C)</td></tr>
     *   <tr><td>19914</td> <td>28992</td> <td>Amersfoort / RD New</td>                             <td>Oblique Stereographic</td></tr>
     *   <tr><td><i>9818</i></td> <td><i>9818</i></td> <td><i>Polyconic</i></td>                    <td><i>Polyconic</i></td></tr>
     *   <tr><td><i>9840</i></td> <td><i>9840</i></td> <td><i>Orthographic</i></td>                 <td><i>Orthographic</i></td></tr>
     *   <tr><td>15399</td> <td>3295</td>  <td>Guam 1963 / Yap Islands</td>                         <td>Modified Azimuthal Equidistant</td></tr>
     *   <tr><td>19952</td> <td>2065</td>  <td>CRS S-JTSK (Ferro) / Krovak</td>                     <td>Krovak</td></tr>
     *   <tr><td><i>9605</i></td> <td>4230</td> <td>ED50 to WGS 84</td>                             <td>Abridged Molodensky</td></tr>
     *   <tr><td>15595</td> <td>5820</td>  <td>EPSG topocentric example B</td>                      <td>Geocentric/topocentric conversions</td></tr>
     * </table>
     *
     * @param  code  the EPSG code of the {@linkplain CoordinateOperation coordinate operation} to create.
     * @return a builder initialized with the coordinate operation (typically a map projection) parameters.
     * @throws FactoryException if the given EPSG code is unknown to this factory.
     *
     * @see ParameterizedTransformTest
     * @see AuthorityFactoryTest
     */
    protected MathTransform.Builder createParameters(final int code) throws FactoryException {
        final var factory = getFactoryOrAbort(MathTransformFactory.class, "No math transform factory found.");
        final MathTransform.Builder builder;
        final ParameterValueGroup parameters;
        switch (code) {
            case 19905: {       // "Makassar / NEIEZ" using operation method 9804
                builder = factory.builder("Mercator (variant A)");                                      // Alias "Mercator (1SP)"
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(6377397.155);                               // Bessel 1841
                parameters.parameter("semi_minor").setValue(6377397.155 * (1 - 1/299.1528128));
                parameters.parameter("Latitude of natural origin")    .setValue(  0.0);
                parameters.parameter("Longitude of natural origin")   .setValue(110.0);
                parameters.parameter("Scale factor at natural origin").setValue(0.997);
                parameters.parameter("False easting").setValue(3900000.0);
                parameters.parameter("False northing").setValue(900000.0);
                break;
            }
            case 19884: {       // "Pulkovo 1942 / Caspian Sea Mercator" using operation method 9805
                builder = factory.builder("Mercator (variant B) ");                                     // Alias "Mercator (2SP)"
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(6378245.0);                                 // Krassowski 1940
                parameters.parameter("semi_minor").setValue(6378245.0 * (1 - 1/298.3));
                parameters.parameter("Latitude of 1st standard parallel").setValue(42.0);
                parameters.parameter("Longitude of natural origin")      .setValue(51.0);
                break;
            }
            case 3856: {        // "WGS 84 / Pseudo-Mercator" using operation method 1024
                builder = factory.builder("Popular Visualisation Pseudo Mercator");
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(6378137.0);                                 // WGS 84
                parameters.parameter("semi_minor").setValue(6378137.0 * (1 - 1/298.2572236));
                break;
            }
            case 4085: {        // "WGS 84 / World Equidistant Cylindrical" using operation method 1028
                builder = factory.builder("Equidistant Cylindrical");
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(6378137.0);                                 // WGS 84
                parameters.parameter("semi_minor").setValue(6378137.0 * (1 - 1/298.2572236));
                break;
            }
            case 310642901: {   // "IGNF:MILLER" (not an official EPSG code)
                builder = factory.builder("Miller_Cylindrical");
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(6378137.0);
                parameters.parameter("semi_minor").setValue(6378137.0);
                break;
            }
            case 19958: {       // "Rectified Skew Orthomorphic Borneo Grid (metres)" using operation method 9815
                builder = factory.builder("Hotine Oblique Mercator (variant B)");
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(6377298.556);                                       // Everest 1830
                parameters.parameter("semi_minor").setValue(6377298.556 * (1 - 1/300.8017));
                parameters.parameter("Latitude of projection centre") .setValue(  4.0);                         //   4°00'00"N
                parameters.parameter("Longitude of projection centre").setValue(115.0);                         // 115°00'00"E
                parameters.parameter("Azimuth of initial line").setValue(53 + (18 + 56.9537/60)/60);            //  53°18'56.9537"
                parameters.parameter("Angle from Rectified to Skew Grid").setValue(53 + (7 + 48.3685/60)/60);   //  53°07'48.3685"
                parameters.parameter("Scale factor on initial line") .setValue(0.99984);
                parameters.parameter("Easting at projection centre") .setValue(590476.87);
                parameters.parameter("Northing at projection centre").setValue(442857.65);
                break;
            }
            case 19916: {       // "British National Grid" using operation method 9807
                builder = factory.builder("Transverse Mercator");
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(6377563.396);                               // Airy
                parameters.parameter("semi_minor").setValue(6377563.396 * (1 - 1/299.32496));
                parameters.parameter("Latitude of natural origin") .setValue(49.0);
                parameters.parameter("Longitude of natural origin").setValue(-2.0);
                parameters.parameter("Scale factor at natural origin").setValue(0.9996012717);
                parameters.parameter("False easting") .setValue( 400000.00);
                parameters.parameter("False northing").setValue(-100000.00);
                break;
            }
            case 17529: {       // "South African Survey Grid zone 29" using operation method 9808
                builder = factory.builder("Transverse Mercator (South Orientated)");
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(6378137.0);                                 // WGS 84
                parameters.parameter("semi_minor").setValue(6378137.0 * (1 - 1/298.2572236));
                parameters.parameter("Latitude of natural origin").setValue(0.0);
                parameters.parameter("Longitude of natural origin").setValue(29.0);
                parameters.parameter("Scale factor at natural origin").setValue(1.0);
                parameters.parameter("False easting") .setValue(0.0);
                parameters.parameter("False northing").setValue(0.0);
                break;
            }
            case 19975: {       // "Trinidad 1903 / Trinidad Grid" using operation method 9806
                /*
                 * Values used below are those published in IOGP Publication 373-7-2 §3.2.2 — September 2019.
                 * They differ from values in EPSG geodetic dataset 9.8.11 in following aspects: geodetic dataset
                 * uses Clarke's foot units instead of foot and link units, with same values for ellipsoid axis
                 * lengths (before conversion) but different values for false easting and northing parameters.
                 * The differences in easting/northing parameters is up to 0.8 metre. We keep the values published
                 * in IOGP 373-7-2 because the sample point tested in map projection is computed with those values.
                 */
                builder = factory.builder("Cassini-Soldner");
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(20926348.0 * FEET);                         // Clarke 1858
                parameters.parameter("semi_minor").setValue(20855233.0 * FEET);
                parameters.parameter("Latitude of natural origin") .setValue(10 + (26 + 30.0/60)/60);   // 10°26'30"N
                parameters.parameter("Longitude of natural origin").setValue(-(61 + 20.0/60));          // 61°20'00"W
                parameters.parameter("False easting") .setValue(430000.00 * LINKS);
                parameters.parameter("False northing").setValue(325000.00 * LINKS);
                break;
            }
            case 19878: {       // "Vanua Levu Grid" using operation method 9833
                builder = factory.builder("Hyperbolic Cassini-Soldner");
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(20926202.0 * FEET);                         // Clarke 1880
                parameters.parameter("semi_minor").setValue(20854895.0 * FEET);
                parameters.parameter("Latitude of natural origin") .setValue(-(16 + 15./60));           // 16°15'00"S
                parameters.parameter("Longitude of natural origin").setValue( 179 + 20./60);            // 179°20'00"E
                parameters.parameter("False easting") .setValue(1251331.8 * LINKS);
                parameters.parameter("False northing").setValue(1662888.5 * LINKS);
                break;
            }
            case 19910: {       // "JAD69 / Jamaica National Grid" using operation method 9801
                builder = factory.builder("Lambert Conic Conformal (1SP)");
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(6378206.4);                                 // Clarke 1866
                parameters.parameter("semi_minor").setValue(6356583.8);
                parameters.parameter("Latitude of natural origin")    .setValue( 18.0);
                parameters.parameter("Longitude of natural origin")   .setValue(-77.0);
                parameters.parameter("Scale factor at natural origin").setValue(  1.0);
                parameters.parameter("False easting") .setValue(250000.00);
                parameters.parameter("False northing").setValue(150000.00);
                break;
            }
            case 14204: {       // "NAD27 / Texas South Central" using operation method 9802
                builder = factory.builder("Lambert Conic Conformal (2SP)");
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(6378206.4);                                 // Clarke 1866
                parameters.parameter("semi_minor").setValue(6356583.8);
                parameters.parameter("Latitude of 1st standard parallel").setValue(28 + 23.0/60);       // 28°23'00"N
                parameters.parameter("Latitude of 2nd standard parallel").setValue(30 + 17.0/60);       // 30°17'00"N
                parameters.parameter("Latitude of false origin")         .setValue(27 + 50.0/60);       // 27°50'00"N
                parameters.parameter("Longitude of false origin")        .setValue(-99.0);              // 99°00'00"W
                parameters.parameter("Easting at false origin") .setValue(2000000 / R_US_FEET);
                parameters.parameter("Northing at false origin").setValue(      0 / R_US_FEET);
                break;
            }
            case 6198: {        // "Michigan CS27 Central zone" using operation method 1051
                builder = factory.builder("Lambert Conic Conformal (2SP Michigan)");
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(6378206.4);                                 // Clarke 1866
                parameters.parameter("semi_minor").setValue(6356583.8);
                parameters.parameter("Latitude of 1st standard parallel").setValue( 44 + 11.0/60);      // 44°11' N
                parameters.parameter("Latitude of 2nd standard parallel").setValue( 45 + 42.0/60);      // 45°42' N
                parameters.parameter("Latitude of false origin")         .setValue( 43 + 19.0/60);      // 43°19' N
                parameters.parameter("Longitude of false origin")        .setValue(-84 - 20.0/60);      // 84°20' W
                parameters.parameter("Easting at false origin") .setValue(2000000 / R_US_FEET);
                parameters.parameter("Northing at false origin").setValue(      0 / R_US_FEET);
                parameters.parameter("Ellipsoid scaling factor").setValue(1.0000382);
                break;
            }
            case 19902: {       // "Belge 1972 / Belge Lambert 72" using operation method 9803
                builder = factory.builder("Lambert Conic Conformal (2SP Belgium)");
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(6378388.0);                                 // International 1924
                parameters.parameter("semi_minor").setValue(6378388.0 * (1 - 1/297.0));
                parameters.parameter("Latitude of 1st standard parallel").setValue(49 + 50.0/60);       // 49°50'00.000"N
                parameters.parameter("Latitude of 2nd standard parallel").setValue(51 + 10.0/60);       // 51°10'00.000"N
                parameters.parameter("Latitude of false origin")         .setValue(90.0);               // 90°00'00.000"N
                parameters.parameter("Longitude of false origin").setValue(4 + (21 + 24.983/60)/60);    //  4°21'24.983"E
                parameters.parameter("Easting at false origin") .setValue( 150000.01);
                parameters.parameter("Northing at false origin").setValue(5400088.44);
                break;
            }
            case 19986: {       // "Europe Equal Area 2001" using operation method 9820
                builder = factory.builder("Lambert Azimuthal Equal Area");
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(6378137.0);
                parameters.parameter("semi_minor").setValue(6378137.0 * (1 - 1/298.2572221));
                parameters.parameter("Latitude of natural origin") .setValue(52.0);
                parameters.parameter("Longitude of natural origin").setValue(10.0);
                parameters.parameter("False easting") .setValue(4321000.00);
                parameters.parameter("False northing").setValue(3210000.00);
                break;
            }
            case 16061: {       // "Universal Polar Stereographic North" using operation method 9810
                builder = factory.builder("Polar Stereographic (variant A)");
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(6378137.0);                                 // WGS84
                parameters.parameter("semi_minor").setValue(6378137.0 * (1 - 1/298.2572236));
                parameters.parameter("Latitude of natural origin").setValue(90.0);
                parameters.parameter("Longitude of natural origin").setValue(0.0);
                parameters.parameter("Scale factor at natural origin").setValue(0.994);
                parameters.parameter("False easting") .setValue(2000000.00);
                parameters.parameter("False northing").setValue(2000000.00);
                break;
            }
            case 19993: {       // "Australian Antarctic Polar Stereographic" using operation method 9829
                builder = factory.builder("Polar Stereographic (variant B)");
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(6378137.0);                                 // WGS84
                parameters.parameter("semi_minor").setValue(6378137.0 * (1 - 1/298.2572236));
                parameters.parameter("Latitude of standard parallel").setValue(-71.0);
                parameters.parameter("Longitude of origin").setValue(70.0);
                parameters.parameter("False easting") .setValue(6000000.00);
                parameters.parameter("False northing").setValue(6000000.00);
                break;
            }
            case 19983: {       // "Petrels 1972 / Terre Adelie Polar Stereographic" using operation method 9830
                builder = factory.builder("Polar Stereographic (variant C)");
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(6378388.0);                                 // International 1924
                parameters.parameter("semi_minor").setValue(6378388.0 * (1 - 1/297.0));
                parameters.parameter("Latitude of standard parallel").setValue(-67.0);
                parameters.parameter("Longitude of origin").setValue(140.0);
                parameters.parameter("Easting at false origin") .setValue(300000.00);
                parameters.parameter("Northing at false origin").setValue(200000.00);
                break;
            }
            case 19914: {       // "RD New" using operation method 9809
                builder = factory.builder("Oblique Stereographic");
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(6377397.155);                               // Bessel 1841
                parameters.parameter("semi_minor").setValue(6377397.155 * (1 - 1/299.15281));
                parameters.parameter("Latitude of natural origin").setValue(52 + ( 9 + 22.178/60)/60);  // 52°09'22.178"N
                parameters.parameter("Longitude of natural origin").setValue(5 + (23 + 15.500/60)/60);  //  5°23'15.500"E
                parameters.parameter("Scale factor at natural origin").setValue(0.9999079);
                parameters.parameter("False easting") .setValue(155000.00);
                parameters.parameter("False northing").setValue(463000.00);
                break;
            }
            case 9818: {        // (not an official EPSG code) using operation method 9818
                builder = factory.builder("Polyconic");
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(6378206.4);
                parameters.parameter("semi_minor").setValue(6356583.8);
                parameters.parameter("Latitude of natural origin") .setValue(0.0);
                parameters.parameter("Longitude of natural origin").setValue(0.0);
                parameters.parameter("False easting") .setValue(0.0);
                parameters.parameter("False northing").setValue(0.0);
                break;
            }
            case 9840: {        // (not an official EPSG code) using operation method 9840
                builder = factory.builder("Orthographic");
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(6378137.0);                                 // WGS84
                parameters.parameter("semi_minor").setValue(6378137.0 * (1 - 1/298.2572236));
                parameters.parameter("Latitude of natural origin").setValue(55.0);
                parameters.parameter("Longitude of natural origin").setValue(5.0);
                parameters.parameter("False easting") .setValue(0.0);
                parameters.parameter("False northing").setValue(0.0);
                break;
            }
            case 15399: {       // "Guam 1963 / Yap Islands" using operation method 9832
                builder = factory.builder("Modified Azimuthal Equidistant");
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(6378206.4);                                 // Clarke 1866
                parameters.parameter("semi_minor").setValue(6356583.8);
                parameters.parameter("Latitude of natural origin").setValue(9 + (32 + 48.15/60)/60);
                parameters.parameter("Longitude of natural origin").setValue(138 + (10 + 7.48/60)/60);
                parameters.parameter("False easting") .setValue(40000.0);
                parameters.parameter("False northing").setValue(60000.0);
                break;
            }
            case 19952: {       // "CRS S-JTSK (Ferro) / Krovak" using operation method 9819
                builder = factory.builder("Krovak");
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(6377397.155);                               // Bessel
                parameters.parameter("semi_minor").setValue(6377397.155 * (1 - 1/299.15281));
                parameters.parameter("Latitude of projection centre").setValue(49.5);                   // 49°30'00"N
                parameters.parameter("Longitude of origin").setValue(24 + 50.0/60);                     // 24°30'00"E
                parameters.parameter("Co-latitude of cone axis").setValue(30 + (17 + 17.3031/60)/60);
                parameters.parameter("Latitude of pseudo standard parallel").setValue(78.5);
                parameters.parameter("Scale factor on pseudo standard parallel").setValue(0.99990);
                break;
            }
            case 9605: {        // (not an official EPSG code) using operation method 9605
                builder = factory.builder("Abridged Molodensky");
                parameters = builder.parameters();
                parameters.parameter("dim").setValue(3);                                                // Parameter defined by OGC 01-009
                parameters.parameter("src_semi_major").setValue(6378137.0);                             // WGS84
                parameters.parameter("src_semi_minor").setValue(6378137.0 * (1 - 1/298.2572236));
                parameters.parameter("X-axis translation").setValue( 84.87);
                parameters.parameter("Y-axis translation").setValue( 96.49);
                parameters.parameter("Z-axis translation").setValue(116.95);
                parameters.parameter("Semi-major axis length difference").setValue(251);
                parameters.parameter("Flattening difference").setValue(1.41927E-05);
                break;
            }
            case 15594: {       // EPSG topocentric example A
                builder = factory.builder("Geographic/topocentric conversions");
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(6378137.0);                               // WGS84
                parameters.parameter("semi_minor").setValue(6378137.0 * (1 - 1/298.2572236));
                parameters.parameter("Latitude of topocentric origin").setValue(55);
                parameters.parameter("Longitude of topocentric origin").setValue(5);
                parameters.parameter("Ellipsoidal height of topocentric origin").setValue(200);
                break;
            }
            case 15595: {       // EPSG topocentric example B
                builder = factory.builder("Geocentric/topocentric conversions");
                parameters = builder.parameters();
                parameters.parameter("semi_major").setValue(6378137.0);                               // WGS84
                parameters.parameter("semi_minor").setValue(6378137.0 * (1 - 1/298.2572236));
                parameters.parameter("Geocentric X of topocentric origin").setValue(3652755.3058);
                parameters.parameter("Geocentric Y of topocentric origin").setValue( 319574.6799);
                parameters.parameter("Geocentric Z of topocentric origin").setValue(5201547.3536);
                break;
            }
            default: {
                throw noSuchAuthorityCode(code, String.valueOf(code));
            }
        }
        validators.validate(parameters);
        return builder;
    }

    /**
     * Creates a coordinate operation from a pair of coordinate reference systems.
     * The default implementation throws {@link NoSuchAuthorityCodeException} unconditionally.
     *
     * @throws FactoryException if this method cannot provide the requested information.
     */
    @Override
    public Set<CoordinateOperation> findCoordinateOperations(final CoordinateReferenceSystem source,
                                                             final CoordinateReferenceSystem target)
            throws FactoryException
    {
        throw new UnimplementedServiceException("Unsupported operation.");
    }

    /**
     * Determine whether two <abbr>CRS</abbr>s are members of one ensemble.
     * The default implementation throws {@link NoSuchAuthorityCodeException} unconditionally.
     *
     * @throws FactoryException if this method cannot provide the requested information.
     */
    @Override
    public boolean areMembersOfSameEnsemble(final CoordinateReferenceSystem source,
                                            final CoordinateReferenceSystem target)
            throws FactoryException
    {
        throw new UnimplementedServiceException("Unsupported operation.");
    }
}
